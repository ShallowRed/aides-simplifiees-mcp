PLAN D’ACTION – AGENT DE CODE SPÉCIALISÉ
=================================================

📅 Date : 2025-10-22
👤 Commanditaire : Équipe Aides Simplifiées / betagouv
💡 Rédigé par : GPT-5 (assistant architecte)

-------------------------------------------------
🎯 CONTEXTE
-------------------------------------------------
Le projet « Aides Simplifiées » vise à moderniser la modélisation et la simulation
des aides publiques via une plateforme web ouverte et modulaire. Il s’adresse
aux administrations et partenaires souhaitant concevoir, maintenir et réutiliser
des simulateurs d’aides (logement, emploi, formation, etc.).

La démarche consiste à :
- Garantir la cohérence entre les artefacts : code, documentation et maquettes Figma.
- Structurer les modèles d’aides pour être lisibles, vérifiables et maintenables.
- Mettre en place un agent (outil) capable de vérifier cette cohérence et de
  suggérer des améliorations de conception et d’architecture.

-------------------------------------------------
🧭 VALEURS CARDINALES
-------------------------------------------------
☑ Lisibilité – chaque règle doit pouvoir être comprise par un non-juriste.
☑ Vérifiabilité – chaque condition de calcul doit être traçable jusqu’à sa source réglementaire.
☑ Maintenabilité – les simulateurs doivent évoluer au rythme du droit.
☑ Interopérabilité – favoriser la mutualisation entre aides et API partagées.
☑ Ouverture – transparence, réutilisation et amélioration collective.

-------------------------------------------------
🏗️ OBJECTIFS TECHNIQUES
-------------------------------------------------
1. Créer une cohérence sémantique entre code, docs et maquettes.
2. Déployer un système MCP (Model Context Protocol) reliant :
   - le code source (GitHub),
   - la documentation (Markdown),
   - les modèles UI (Figma),
   - les règles métiers (YAML/JSON).
3. Mettre en place un linter sémantique (domain_term_linter) pour normaliser les champs.
4. Intégrer un pipeline CI/CD vérifiant les écarts et assurant la conformité des simulateurs.
5. Préparer un agent d’analyse architecturale capable de proposer des refactorings.

-------------------------------------------------
📋 PLAN D’ACTION DÉTAILLÉ – TÂCHES SUIVIES
-------------------------------------------------

### 🧩 Phase 1 — Structuration du domaine (J+3)
[ ] Intégrer le glossaire `glossaire.yaml` dans le dépôt documentation.
[ ] Publier la charte de nommage et conventions (issues docs).
[ ] Définir la table de correspondance IDs → slugs (UI → canonique).
[ ] Ajouter un script de traduction `idToSlug()` dans le dépôt app.

### ⚙️ Phase 2 — Mise en place du linter et CI (J+7)
[ ] Intégrer le code MCP `mcp-arch` (starter TypeScript déjà fourni).
[ ] Configurer la commande CLI locale `npm run lint:domain`.
[ ] Ajouter un GitHub Action déclenchant le linter sur chaque PR JSON.
[ ] Enregistrer les rapports de lint en artefacts CI.
[ ] Paramétrer les niveaux de sévérité (error/warn).

### 🔗 Phase 3 — Synchronisation Docs & API (J+14)
[ ] Ajouter le tool `api_drift_check` dans `mcp-arch`.
[ ] Relier les endpoints API documentés aux routes implémentées.
[ ] Déclencher une PR automatique sur divergence détectée (Doc Sync).
[ ] Intégrer un commentaire de résumé sur chaque PR.

### 🎨 Phase 4 — Cohérence UI/Figma (J+20)
[ ] Configurer le serveur MCP `mcp-figma` (clé API Figma).
[ ] Ajouter le tool `route_to_screen_map` pour associer routes ↔ frames Figma.
[ ] Définir une convention de nommage Figma (tokens : field.slug).
[ ] Générer un rapport de correspondance des écrans par simulateur.

### 🧠 Phase 5 — Analyse architecturale & refactoring (J+30)
[ ] Ajouter les tools `compute_coupling_metrics` et `detect_duplication`.
[ ] Générer un graphe de dépendances du code.
[ ] Produire un rapport de complexité et de duplication par module.
[ ] Proposer les refactorings prioritaires (extraction de moteurs partagés).

### 🔒 Phase 6 — Gouvernance & maintenance continue (J+40)
[ ] Mettre en place un log d’audit pour les actions MCP.
[ ] Centraliser les règles dans un dépôt unique `aides-simplifiees-rules`.
[ ] Documenter le process de contribution et revue (contributeurs publics).
[ ] Définir la politique de versionning des simulateurs et modèles.
[ ] Organiser un atelier interne “Architecture vivante” pour validation.

-------------------------------------------------
📈 INDICATEURS DE SUCCÈS
-------------------------------------------------
- [ ] 100 % des champs JSON conformes au glossaire.
- [ ] 0 erreurs « high severity » sur CI.
- [ ] Documentation et API synchronisées automatiquement.
- [ ] Couplage entre modules réduit (>20 %).
- [ ] Figma et code partagent >90 % de correspondance d’IDs.

-------------------------------------------------
🧩 PROCHAINS LIVRABLES
-------------------------------------------------
- ✅ Glossaire v1.0 (fourni)
- 🧰 Linter MCP (starter livré)
- 🔄 GitHub Action de lint
- 🧾 Rapport de cohérence et refactorings

-------------------------------------------------
🗝️ CONTACTS ET RESPONSABILITÉS
-------------------------------------------------
- **Responsable technique / architecte** : [à désigner]
- **Designer / référent Figma** : [à désigner]
- **Agent de code spécialisé (vous)** : responsable de l’intégration, de la CI et du linting.
- **Référent produit / domaine** : [à désigner]

-------------------------------------------------
✅ CONCLUSION
-------------------------------------------------
L’objectif est d’outiller durablement la cohérence et la maintenabilité du projet.
Le MCP servira de colonne vertébrale entre code, documentation, modèles et
simulateurs pour assurer la qualité, la transparence et la réutilisation du service.

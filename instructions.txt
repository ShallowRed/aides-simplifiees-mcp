PLAN Dâ€™ACTION â€“ AGENT DE CODE SPÃ‰CIALISÃ‰
=================================================

ğŸ“… Date : 2025-10-22
ğŸ‘¤ Commanditaire : Ã‰quipe Aides SimplifiÃ©es / betagouv
ğŸ’¡ RÃ©digÃ© par : GPT-5 (assistant architecte)

-------------------------------------------------
ğŸ¯ CONTEXTE
-------------------------------------------------
Le projet Â« Aides SimplifiÃ©es Â» vise Ã  moderniser la modÃ©lisation et la simulation
des aides publiques via une plateforme web ouverte et modulaire. Il sâ€™adresse
aux administrations et partenaires souhaitant concevoir, maintenir et rÃ©utiliser
des simulateurs dâ€™aides (logement, emploi, formation, etc.).

La dÃ©marche consiste Ã  :
- Garantir la cohÃ©rence entre les artefacts : code, documentation et maquettes Figma.
- Structurer les modÃ¨les dâ€™aides pour Ãªtre lisibles, vÃ©rifiables et maintenables.
- Mettre en place un agent (outil) capable de vÃ©rifier cette cohÃ©rence et de
  suggÃ©rer des amÃ©liorations de conception et dâ€™architecture.

-------------------------------------------------
ğŸ§­ VALEURS CARDINALES
-------------------------------------------------
â˜‘ LisibilitÃ© â€“ chaque rÃ¨gle doit pouvoir Ãªtre comprise par un non-juriste.
â˜‘ VÃ©rifiabilitÃ© â€“ chaque condition de calcul doit Ãªtre traÃ§able jusquâ€™Ã  sa source rÃ©glementaire.
â˜‘ MaintenabilitÃ© â€“ les simulateurs doivent Ã©voluer au rythme du droit.
â˜‘ InteropÃ©rabilitÃ© â€“ favoriser la mutualisation entre aides et API partagÃ©es.
â˜‘ Ouverture â€“ transparence, rÃ©utilisation et amÃ©lioration collective.

-------------------------------------------------
ğŸ—ï¸ OBJECTIFS TECHNIQUES
-------------------------------------------------
1. CrÃ©er une cohÃ©rence sÃ©mantique entre code, docs et maquettes.
2. DÃ©ployer un systÃ¨me MCP (Model Context Protocol) reliant :
   - le code source (GitHub),
   - la documentation (Markdown),
   - les modÃ¨les UI (Figma),
   - les rÃ¨gles mÃ©tiers (YAML/JSON).
3. Mettre en place un linter sÃ©mantique (domain_term_linter) pour normaliser les champs.
4. IntÃ©grer un pipeline CI/CD vÃ©rifiant les Ã©carts et assurant la conformitÃ© des simulateurs.
5. PrÃ©parer un agent dâ€™analyse architecturale capable de proposer des refactorings.

-------------------------------------------------
ğŸ“‹ PLAN Dâ€™ACTION DÃ‰TAILLÃ‰ â€“ TÃ‚CHES SUIVIES
-------------------------------------------------

### ğŸ§© Phase 1 â€” Structuration du domaine (J+3)
[ ] IntÃ©grer le glossaire `glossaire.yaml` dans le dÃ©pÃ´t documentation.
[ ] Publier la charte de nommage et conventions (issues docs).
[ ] DÃ©finir la table de correspondance IDs â†’ slugs (UI â†’ canonique).
[ ] Ajouter un script de traduction `idToSlug()` dans le dÃ©pÃ´t app.

### âš™ï¸ Phase 2 â€” Mise en place du linter et CI (J+7)
[ ] IntÃ©grer le code MCP `mcp-arch` (starter TypeScript dÃ©jÃ  fourni).
[ ] Configurer la commande CLI locale `npm run lint:domain`.
[ ] Ajouter un GitHub Action dÃ©clenchant le linter sur chaque PR JSON.
[ ] Enregistrer les rapports de lint en artefacts CI.
[ ] ParamÃ©trer les niveaux de sÃ©vÃ©ritÃ© (error/warn).

### ğŸ”— Phase 3 â€” Synchronisation Docs & API (J+14)
[ ] Ajouter le tool `api_drift_check` dans `mcp-arch`.
[ ] Relier les endpoints API documentÃ©s aux routes implÃ©mentÃ©es.
[ ] DÃ©clencher une PR automatique sur divergence dÃ©tectÃ©e (Doc Sync).
[ ] IntÃ©grer un commentaire de rÃ©sumÃ© sur chaque PR.

### ğŸ¨ Phase 4 â€” CohÃ©rence UI/Figma (J+20)
[ ] Configurer le serveur MCP `mcp-figma` (clÃ© API Figma).
[ ] Ajouter le tool `route_to_screen_map` pour associer routes â†” frames Figma.
[ ] DÃ©finir une convention de nommage Figma (tokens : field.slug).
[ ] GÃ©nÃ©rer un rapport de correspondance des Ã©crans par simulateur.

### ğŸ§  Phase 5 â€” Analyse architecturale & refactoring (J+30)
[ ] Ajouter les tools `compute_coupling_metrics` et `detect_duplication`.
[ ] GÃ©nÃ©rer un graphe de dÃ©pendances du code.
[ ] Produire un rapport de complexitÃ© et de duplication par module.
[ ] Proposer les refactorings prioritaires (extraction de moteurs partagÃ©s).

### ğŸ”’ Phase 6 â€” Gouvernance & maintenance continue (J+40)
[ ] Mettre en place un log dâ€™audit pour les actions MCP.
[ ] Centraliser les rÃ¨gles dans un dÃ©pÃ´t unique `aides-simplifiees-rules`.
[ ] Documenter le process de contribution et revue (contributeurs publics).
[ ] DÃ©finir la politique de versionning des simulateurs et modÃ¨les.
[ ] Organiser un atelier interne â€œArchitecture vivanteâ€ pour validation.

-------------------------------------------------
ğŸ“ˆ INDICATEURS DE SUCCÃˆS
-------------------------------------------------
- [ ] 100 % des champs JSON conformes au glossaire.
- [ ] 0 erreurs Â« high severity Â» sur CI.
- [ ] Documentation et API synchronisÃ©es automatiquement.
- [ ] Couplage entre modules rÃ©duit (>20 %).
- [ ] Figma et code partagent >90 % de correspondance dâ€™IDs.

-------------------------------------------------
ğŸ§© PROCHAINS LIVRABLES
-------------------------------------------------
- âœ… Glossaire v1.0 (fourni)
- ğŸ§° Linter MCP (starter livrÃ©)
- ğŸ”„ GitHub Action de lint
- ğŸ§¾ Rapport de cohÃ©rence et refactorings

-------------------------------------------------
ğŸ—ï¸ CONTACTS ET RESPONSABILITÃ‰S
-------------------------------------------------
- **Responsable technique / architecte** : [Ã  dÃ©signer]
- **Designer / rÃ©fÃ©rent Figma** : [Ã  dÃ©signer]
- **Agent de code spÃ©cialisÃ© (vous)** : responsable de lâ€™intÃ©gration, de la CI et du linting.
- **RÃ©fÃ©rent produit / domaine** : [Ã  dÃ©signer]

-------------------------------------------------
âœ… CONCLUSION
-------------------------------------------------
Lâ€™objectif est dâ€™outiller durablement la cohÃ©rence et la maintenabilitÃ© du projet.
Le MCP servira de colonne vertÃ©brale entre code, documentation, modÃ¨les et
simulateurs pour assurer la qualitÃ©, la transparence et la rÃ©utilisation du service.
